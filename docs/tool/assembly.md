# 汇编语言
这里面是2020年时候记的笔记，内容来自李明杰的视频和王爽老师的汇编语言。

常见的汇编有以下几种，不同的汇编语言针对的设备不同，语法都大同小异：
```markdown
* 8086汇编  16位
* Win2汇编  32位
* Win64汇编  64位
* AT&T汇编  MAC、iOS模拟器
* ARM汇编  嵌入式、iOS设备
```

## 总线
总线有：地址总线、数据总线、控制总线

地址总线作用是寻址,CPU从地址总线找到内存中对应的位置，控制总线确定是读还是写，从数据总线传递

地址总线的宽度决定了CPU的寻址能力，8086汇编的地址总线宽度是20，寻址能力是1M（2的20次方）
地址总线的宽度是根据有多少根导线控制的，一根导线可以传高电平和低电平两种信号，所以20根导线的寻址能力是2的20次方。

宽度决定CPU的单次数据传送量，也就是传送速度，
8086的数据总线宽度是16，单次最大传送2个字节的数据，一个字节是8个bit。

控制总线: 宽度决定CPU对其它器件的控制能力

8086的寻址方式是采用两个16位地址合成的方法来生成一个20位的物理地址。
```markdown
等于 `段地址 * 16 + 偏移地址`。
相当于`段地址 * 10H + 偏移地址`，16 在16进制中用`10H`表示。
```

## 字节和字
字节 byte: 1个字节由8个bit组成，可以存储在8位寄存器中
字 word: 1个字有2个字节，2个字节可以分为字的高子杰和低字节。

## segment 段
Code segment 代码段
Data segment 数据段
Stack segment 堆栈段
Extra segment 附加段

当CPU访问内存时，由段寄存器提供内存单元的段地址

## CS:IP 指令的执行过程：
```markdown
1. 从CS:IP指向的内存单元读取指令，读取到的指令进入指令缓冲器
2. IP= IP + 读取指令的长度，从而指向下一条指令
3. 执行指令,传到 第 1 步，重复这个过程 
```

>任意时刻，8086CPU都会将CS:IP指向的指令作为下一条需要取出执行的指令

## Jmp指令
1. Jmp 段地址:偏移地址 （修改cs:ip）
2. Jmp 偏移地址  （只修改ip）

## Debug常用指令

命令 | 含义
------- | -------
R | 查看、改变CPU寄存器的内容
D | 查看内存中的内容
E | 改写内存中的内容
U | 将内存中的机器指令翻译成汇编指令
T | 执行一条机器指令
A | 以汇编指令的格式在内存中写入一条机器指令
q | 退出Debug
p | 类似于step over，用于跳过loop循环
g | 跳过前面的代码，停留在指定的代码位置

## DS 和 [address]
CPU要读写一个内存单元时，必须给出这个内存单元的地址，在8086中，内存地址由`段地址和偏移地址`组成，格式`ds 寄存器`,用来存放要访问数据的段地址。
```
mov bx 1000H
mov ds,bx   // ds不能直接更改
mov al,[0]  // [0]相当于1000:[0]
```

## 大小端
将一个多位数的低位放在较小的地址处，高位放在较大的地址处，则称**小端序**；反之则称**大端序**

比如一个int类型，位于地址0x100处,地址范围为`0x100~0x103`，它的值为0x01234567，字节，大小端模式的排序如下:

模式 | 地址 | 存储值 
------- | ------- | -------
大端模式 | 0x100<br>0x101<br>0x102<br>0x103 | 0x01<br>0x23<br>0x45<br>0x67
小端模式 | 0x100<br>0x101<br>0x102<br>0x103  | 0x67<br>0x45<br>0x12<br>0x01

## 栈
栈的特点，先进后出。8086将ss作为栈段的段地址，任意时刻将`ss:sp`指向栈顶，push 是入栈，pop 是出栈。8086CPU栈操作都是以字为单位。
```
push ax     //将ax的数据入栈
pop ax      //将栈顶的数据送入ax
```

## 中断
中断是由于硬件或软件的信号，使CPU暂停当前的任务，转而去执行另一段程序，中断分为硬中断和软中断。
```markdown
* 硬中断： 外部设备引起的，比如网卡、硬盘
* 软中断：执行中断指令产生的，可以通过程序控制触发，
```
中断指令通过`int n`实现，n是中断码，内存中有一张中断向量表，用来存放中断码对应中断处理程序的入口地址。常见的中断有：
```markdown
int 10h // 执行BIOS中断
int 13 // 断点中断，用于调试程序
int 21h // 执行DOS系统功能调试，AH寄存器
```

## 汇编写helloworld
完整的Hello World 汇编版本
```
assume cs:code, ds:data  // 这里是定义变量，表示在那个段

data segment
    db 'Hello world!$'  //$表示字符串结束,这是一个数据段
data ends

code segment
start:
    mov ax, data
    mov ds, ax      //这两句是设置ds
    mov dx, oh      //设置dx
    mov ah, qh      //打印
    int 21h
    mov ax,4C00h    //退出程序
    int 21h
code ends
end start   // 程序结束

start: end start // 告诉编译器入口
```
中断前ah传的值是qh,表示打印字符串，`int 21h`系统中断，根据ah的值做对应的事情，`ah=4c`表示程序退出。

## call和ret
call会将下一条偏移地址的指令入栈，ret将栈顶的值出栈，赋值给IP
```
stack segment
    db 100 dup(0)   // 初始化100字节，值为0
stack ends

data segment
    db 100 dup(0)
    string db 'Hello$'
data ends

code segment
start:
    mov ax,data
    mov ds,ax
    mov ax,stack
    mov ss,ax,
    call print   //调用print方法

    mov ax,4c00h    // 退出
    int 21h
print:
    mov dx,offset string
    mov ah,qh
    int 21h
    ret
code ends
end start
```

函数调用完成之后为什么能回到原来的位置？
因为调用时会将下一条指令的偏移地址入栈，执行完之后出栈，将IP设置成栈中的地址，call入栈，ret出栈，设置IP，

函数的返回值：
函数的返回值一般放在ax寄存器中，函数的传参使用栈或使用寄存器传参

## 栈平衡
栈平衡：函数调用前后的栈顶指针要一致。栈平衡分内平衡（函数内）、外平衡（函数外）。

多参数传送: iOS中会使用栈，少量参数iOS使用寄存器传值。

>汇编中为了给函数空间，会开辟一个栈空间给函数使用，栈要注意BP/SP， SP是栈顶，BP是栈低

```markdown
sum:
    push bP     //保护bp
    mov bp,sp   //保护sp之前的值，指向bp以前的值
    sub sp,10   //预留10个字节给局部变量
    push sb     //保护可能用到的其他寄存器
    mov word ptr ss:[bp-2],3
    mov word prt ss:[bp-4],4
    mov ax,ss:[bp-2]
    mov ax,ss:[bp-4]
    pop sb      // 恢复sb之前的值
    mov sp,bp   // 恢复sp,也可以使用 add sp,0x10
    pop bp      // 保护bp
    ret
```

## 函数的调用流程（内存）
```markdown
1. push 参数
2. push 函数的返回地址
3. push bp  // 保留bp之前的值，方便之后恢复
4. mov bp,sp  // 保留sp之前的值，方便之后恢复
5. sub sp,空间大小  // 分配控件给局部变量
6. 保护可能用到的寄存器
7. 执行业务逻辑
8. 恢复寄存器之前的值
9. mov sp,bp  // 恢复sp之前的值
10. pop bp  // 恢复bp之前的值
11. ret  // 将函数返回地址出栈，执行下一条指令
12. 恢复栈平衡，现在的流程使用的是外平衡
```